<!DOCTYPE html>
<html lang="en" class="no-js">

<!-- /composition-vs-inheritance/  Mon, 24 Jan 2022 10:07:09 GMT -->
<!-- OpenDir --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /OpenDir -->
<head>
    <meta charset="UTF-8">
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>

<title>Composition vs Inheritance | Learn JavaScript</title>
<meta name="description" content="Learn JavaScript student portal"/>
<link rel="canonical" href="index.html">


<!-- Favicons -->
<link rel="apple-touch-icon" sizes="180x180" href="../../favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicons/favicon-16x16.png">
<link rel="manifest" href="../../favicons/site.webmanifest">
<link rel="mask-icon" href="../../favicons/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="../../favicons/favicon.ico">
<meta name="msapplication-TileColor" content="#ffc40d">
<meta name="msapplication-config" content="../../favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">

<!-- CSS -->
<link rel="stylesheet" href="../../css/styles-min-afc4baccb2.css">

<!-- Fonts -->
<script>
  (function (d) {
    var config = {
        kitId: 'gas0cwl',
        scriptTimeout: 3000,
        async: true
      },
      h = d.documentElement,
      t = setTimeout(function () {
        h.className = h
          .className
          .replace(/\bwf-loading\b/g, "") + " wf-inactive";
      }, config.scriptTimeout),
      tk = d.createElement("script"),
      f = false,
      s = d.getElementsByTagName("script")[0],
      a;
    h.className += " wf-loading";
    tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
    tk.async = true;
    tk.onload = tk.onreadystatechange = function () {
      a = this.readyState;
      if (f || a && a != "complete" && a != "loaded")
        return;
      f = true;
      clearTimeout(t);
      try {
        Typekit.load(config)
      } catch (e) {}
    };
    s
      .parentNode
      .insertBefore(tk, s)
  })(document);
</script>

<script>
  document
    .documentElement
    .classList
    .remove('no-js')
</script>

</head>

  <body class="page">
      <nav class="main-nav" data-js="menu" data-state="closed">
        <div>
          <a href="../index.html"><svg
  class="logo"
  data-size="small"
  height="1em"
  viewbox="0 0 273 43"
  xmlns="http://www.w3.org/2000/svg"
>
  <g transform="translate(-1 -10)" fill="none" fill-rule="evenodd">
    <rect fill="#F8E201" x="31" y="11" width="217" height="42" />
    <path
      d="M5.21 44.261v-5.217c0-2.726-.706-4.418-3.902-5.076v-3.76c3.196-.705 3.901-2.209 3.901-4.841v-6.11c0-4.606 2.68-8.178 8.695-8.178h1.551v3.995c-3.948 0-5.546 1.645-5.546 5.264v4.23c0 3.196-.94 6.345-4.136 7.473 3.102 1.175 4.136 4.042 4.136 7.05v4.089c0 4.183 1.598 5.828 5.546 5.828v3.995h-1.55c-5.782 0-8.696-3.243-8.696-8.742zm263.967-5.217l.141 5.217c-.141 5.499-2.961 8.742-8.789 8.742h-1.551v-3.995c3.948 0 5.499-1.645 5.499-5.828v-4.089c0-3.008 1.081-5.875 4.183-7.05-3.196-1.128-4.183-4.277-4.183-7.473v-4.23c0-3.619-1.551-5.264-5.499-5.264v-3.995h1.551c5.969 0 8.648 3.572 8.648 8.178v6.11c0 2.632.705 4.136 3.901 4.841v3.76c-3.196.658-3.901 2.35-3.901 5.076z"
      fill="#000"
      fill-rule="nonzero"
    />
    <path
      d="M29.82 52V11.5h7.74v34.56h17.46V52h-25.2zM58.2 37.78c0-8.16 3.54-16.32 13.68-16.32 8.4 0 12.18 5.1 12.18 13.62 0 .96-.06 1.92-.12 3H65.76c.06 7.44 3 9.36 6.54 9.36 2.76 0 5.52-1.2 5.52-4.2 0-.24-.06-.48-.06-.78l6 .84c.06.3.06.66.06 1.02 0 5.4-5.28 8.4-11.76 8.4-8.04 0-13.86-4.62-13.86-14.94zm13.62-11.7c-2.76 0-5.04 2.04-5.82 7.5h10.56v-1.02c0-3.48-1.38-6.48-4.74-6.48zM88.2 44.26c0-6.36 6.06-9.54 12.42-9.54 2.64 0 4.02.6 4.62.96v-4.32c0-3.42-1.32-5.1-4.44-5.1-3.66 0-4.8 2.4-3.96 5.7l-7.02-.78c-1.56-6.84 4.2-9.72 11.4-9.72 7.98 0 11.34 3.48 11.34 9.9v13.26c0 1.38.36 2.04 1.2 2.04 1.08 0 1.92-.96 1.92-.96l.42 5.22s-2.04 1.5-4.92 1.5c-2.94 0-4.98-1.5-5.46-4.62-1.56 2.94-4.56 4.92-8.46 4.92-5.16 0-9.06-3.48-9.06-8.46zm11.28 3.18c2.46 0 4.26-1.38 5.76-3.06v-5.16c-.6 0-1.38-.06-2.34-.06-4.8 0-7.44 1.44-7.44 4.62 0 2.46 1.62 3.66 4.02 3.66zM120.96 52V22.18h5.58l1.02 5.52c1.2-3.18 3.6-6.24 8.1-6.24 6.24 0 7.62 6.66 5.7 11.28l-6.3.84c.84-2.4.96-6-2.04-6-2.64 0-3.96 2.46-4.68 4.56V52h-7.38zm25.86 0V22.18h5.58l.9 4.86c2.22-3.24 4.68-5.58 9.36-5.58 5.04 0 8.88 2.82 8.88 9.18V52h-7.38V32.08c0-3.24-1.2-4.68-3.96-4.68-2.64 0-4.44 1.26-6 2.88V52h-7.38zm47.46-34.86V11.5h17.46v28.8c0 7.5-4.2 12.42-12.18 12.42-8.52 0-13.14-5.52-10.98-13.5l6.84-.72c-1.26 5.16-.06 8.4 3.96 8.4 3.06 0 4.62-1.92 4.62-5.58V17.14h-9.72zm23.94 22.62l6.9-.72c-1.08 4.26 1.2 7.98 8.1 7.98 5.46 0 7.2-2.4 7.2-5.16 0-3.66-3.3-5.04-8.04-6.66-5.76-1.98-13.44-4.38-13.44-12.84 0-7.2 5.52-11.7 14.88-11.58 11.04.12 14.94 6.42 13.74 13.32l-7.32.72c.78-5.76-1.56-8.46-6.96-8.46-4.56 0-6.54 2.04-6.54 5.04 0 4.02 3.72 5.34 8.4 6.9 6.06 1.98 13.02 4.32 13.02 12.36 0 6.84-5.1 12.06-15.24 12.06-9.48 0-16.08-4.5-14.7-12.96z"
      fill="#000"
      fill-rule="nonzero"
    />
  </g>
</svg>
</a>
          <button data-type="secondary" data-js="menu-button">Menu</button>
        </div>
        <div>
          <a href="../index.html">Contents</a>
          <a href="../../components/index.html">Components</a>
          <a href="../../community/index.html">Community</a>
          <a href="../../extras/index.html">Extras</a>
        </div>
        <div>
          <a href="../..https://nerd-dir.com">Account</a>
          <button data-type="secondary" data-js="logout">OpenDir</button>
        </div>
      </nav>

    <noscript>
      <div class="wrap">
        This portal uses JavaScript to check your identity. Please enable JavaScript to access the course.
      </div>
    </noscript>

    <main>
      <div class="wrap">
<div
  data-js="check-auth"
  data-required-authorization="mastery"
  data-auth-state="failure"
>
  <article class="longform" data-failed-content>
    <h1>Composition vs Inheritance</h1>
    <p>Hey <span data-js="user-data" data-field="firstName">,</p>
      <p>
      I'm thrilled to help you learn JavaScript. Unfortunately, you've landed on a page where you cannot access with your current purchase.
    </p>
      <p>
      Please upgrade (<a href="../../404/index.html" data-upgrade-link
        >use this link</a
      >) access this content.
    </p>

      <p>I'm super eager to help you learn more!</p>
    </article>

    <article class="longform" data-content>
      <h1>Composition vs Inheritance</h1>



      <div class="meta source-code">


      </div><p>Imagine you want to create a Developer and Designer. They have the following characteristics:</p>
<ol>
<li>Both Developer and Designer should have <code>firstName</code> and <code>lastName</code></li>
<li>Both Developer and Designer should have the ability to <code>sayName</code></li>
<li>Developers can <code>code</code>, but Designers can‚Äôt.</li>
<li>Designers can <code>design</code>, but Developers can‚Äôt.</li>
</ol>
<p>How would you create this?</p>
<p>Here‚Äôs one possibility: We can create a <code>Human</code> class that contains <code>firstName</code>, <code>lastName</code>, and <code>sayName</code>.</p>
<pre><code class="language-js">class Human {
  constructor (firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
  }

  sayName () {
    console.log(`${this.firstName} ${this.lastName}`)
  }
}
</code></pre>
<p>Since Developers are Humans, we can extend the <code>Human</code> class to create a <code>Developer</code> class.</p>
<pre><code class="language-js">class Developer extends Human {
  // ...
}
</code></pre>
<p>We‚Äôll add <code>code</code> to <code>Developer</code> since developers can code.</p>
<pre><code class="language-js">class Developer extends Human {
  code (thing) {
    console.log(`${this.firstName} coded ${thing}`)
  }
}
</code></pre>
<p>Designers are also human. We can extend <code>Human</code> to create a <code>Designer</code> class.</p>
<pre><code class="language-js">class Designer extends Human {
  // ...
}
</code></pre>
<p>We‚Äôll add the <code>design</code> method to <code>Designer</code> since designers can design.</p>
<pre><code class="language-js">class Designer extends Human {
  design (thing) {
    console.log(`${this.firstName} designed ${thing}`)
  }
}
</code></pre>
<h2 id="inheriting-from-two-classes">Inheriting from two Classes</h2>
<p>Let‚Äôs say there‚Äôs a person who can design and code. How would you create this person?</p>
<ol>
<li>You can‚Äôt use <code>Developer</code> since developers cannot design.</li>
<li>You can‚Äôt use <code>Designer</code> since designers cannot code.</li>
</ol>
<p>Maybe you can create a subclass from both classes?</p>
<p>We‚Äôll use <code>DesignerWhoCodes</code> as a constructor for this person (but it can also be <code>CoderWhoDesigns</code> or <code>Unicorn</code> or something else you prefer).</p>
<pre><code class="language-js">// Doesn't work
class DesignerWhoCodes extends Designer, Developer {
  // ...
}
</code></pre>
<p>Unfortunately, this doesn‚Äôt work in JavaScript.</p>
<figure role="figure">
  <img src="../../images/oop/composition-vs-inheritance/multiple-inheritance-error.png" alt="">
</figure>
<p>JavaScript doesn‚Äôt let you inherit from multiple classes because it uses Prototypal Delegation.</p>
<p><strong>You can only delegate to one prototype.</strong></p>
<h2 id="composing-using-mixins">Composing Using Mixins</h2>
<p>One way to create <code>DesignerWhoCodes</code> is to use Mixins. Mixins are objects that contain properties you want to ‚Äúmix‚Äù into another object.</p>
<p>To use Mixins, we have to redesign <code>Human</code>. We will place all skills (like <code>sayName</code>, <code>design</code>, and <code>code</code>) in separate objects.</p>
<pre><code class="language-js">// Skills
const canCode = {
  code (thing) {
    console.log(`${this.firstName} coded ${thing}`)
  }
}

const canDesign = {
  design (thing) {
    console.log(`${this.firstName} designed ${thing}`)
  }
}

const canSayName = {
  sayName () {
    console.log(`${this.firstName} ${this.lastName}`)
  }
}
</code></pre>
<p>Next, we will construct a <code>Human</code> with <code>firstName</code> and <code>lastName</code> properties.</p>
<pre><code class="language-js">class Human {
  constructor (firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
  }
}
</code></pre>
<p>We can create a <code>Developer</code> by extending <code>Human</code> like before.</p>
<pre><code class="language-js">class Developer extends Human {}
</code></pre>
<p>Developers should be able to <code>code</code> and <code>sayName</code>. We can mix <code>canCode</code> and <code>canSayName</code> into <code>Developer</code> to give these skills to <code>Developer</code>.</p>
<p>We mix the skills into Developer‚Äôs prototype with <code>Object.assign</code>.</p>
<pre><code class="language-js">Object.assign(Developer.prototype, canCode, canSayName)
</code></pre>
<p>A Developer instance can now <code>sayName</code> and <code>code</code>. But it cannot design.</p>
<pre><code class="language-js">const zell = new Developer('Zell', 'Liew')

zell.sayName() // Zell Liew
zell.code('website') // Zell coded website
zell.design('website') // Error
</code></pre>
<figure role="figure">
  <img src="../../images/oop/composition-vs-inheritance/developer.png" alt="Developer instance.">
</figure>
<p>We can repeat the same process to create a designer. We will extend <code>Human</code> to create <code>Designer</code>.</p>
<pre><code class="language-js">class Designer extends Human {}
</code></pre>
<p>Designers can <code>sayName</code> and <code>design</code>, but they cannot code. We can mix these skills in with <code>Object.assign</code>.</p>
<pre><code class="language-js">Object.assign(Designer, canDesign, canSayName)
</code></pre>
<p>A <code>Designer</code> instance can now <code>design</code> and <code>sayName</code>. But it cannot <code>code</code>.</p>
<pre><code class="language-js">const vincy = new Designer('Vincy', 'Zhang')

vincy.sayName() // Vincy Zhang
vincy.design('website') // Vincy designed website
vincy.code('website') // Error
</code></pre>
<figure role="figure">
  <img src="../../images/oop/composition-vs-inheritance/designer.png" alt="Designer instance.">
</figure>
<p>We can (once again) repeat the same steps to create <code>DesignerWhoCodes</code>.</p>
<pre><code class="language-js">class DesignerWhoCodes extends Human {}
Object.assign(DesignerWhoCodes, canCode, canDesign, canSayName)
</code></pre>
<p>A <code>DesignerWhoCodes</code> instance can <code>sayName</code>, <code>code</code>, and <code>design</code>.</p>
<pre><code class="language-js">const tracy = new DesignerWhoCodes('Tracy', 'Lim')

tracy.sayName() // Tracy Lim
tracy.code('website') // Tracy coded website
tracy.design('website') // Tracy designed website
</code></pre>
<figure role="figure">
  <img src="../../images/oop/composition-vs-inheritance/designer-who-codes.png" alt="DesignerWhoCodes instance.">
</figure>
<h3 id="mixins-uses-copy-pasting">Mixins uses Copy-pasting</h3>
<p>When we combine objects with <code>Object.assign</code>, we copy properties from the later object into the earlier object. Therefore, <strong>Mixins uses Copy-pasting or Concatenative Inheritance</strong>.</p>
<h3 id="mixins-and-composition">Mixins and Composition</h3>
<p>Composition means to combine things together. In this case, we combine skills (each skill is an object) into the subclasses prototype (another object).</p>
<p>Since we combine objects, we can say <strong>Mixins uses Object Composition.</strong></p>
<pre><code class="language-js">// Object Composition
Object.assign(object1, object2)
</code></pre>
<p>There is another form of composition in JavaScript known as Function Composition, where we combine functions together to make a new function.</p>
<pre><code class="language-js">// Function Composition
const finalFunction = compose(function1, function2)
</code></pre>
<p>Don‚Äôt mix up Object Composition and Function Composition! (We won‚Äôt cover Function Composition much since we‚Äôre not touching Functional Programming in this course).</p>
<h2 id="favour-composition-over-inheritance">Favour Composition over Inheritance</h2>
<p>When people say favour composition over inheritance, they mean the following terms:</p>
<ol>
<li>Composition means Object Composition</li>
<li>Inheritance means Subclassing</li>
</ol>
<p>They actually mean favour Object Composition over Subclassing.</p>
<p>Why?</p>
<p>When you design software, it‚Äôs impossible to know all future requirements in advance. Things will change. You‚Äôll have to make adjustments. When you compose objects, you can create derivative objects without limiting yourself to a fixed structure.</p>
<p>Example:</p>
<p>Let‚Äôs say we have a new requirement now. We need a <code>Robot</code> who can <code>design</code> and <code>code</code>. But <code>Robot</code> cannot <code>sayName</code>.</p>
<p>How would you create <code>Robot</code>?</p>
<p>It‚Äôs super hard to create <code>Robot</code> if you used subclasses. But if you composed skills into the derivative object, you can always create a new <code>Robot</code>. For example, we can extend <code>Human</code> to create <code>Robot</code>, then give it <code>canCode</code> and <code>canDesign</code>.</p>
<pre><code class="language-js">class Robot extends Human {}
Object.assign(Robot.prototype, canCode, canDesign)
</code></pre>
<p>This works‚Ä¶ but it‚Äôs weird for <code>Robot</code> to be a subclass of <code>Human</code>‚Ä¶ right? With this, we see another downside with subclassing: It can be really hard to name abstractions.</p>
<h3 id="skipping-subclassing-entirely">Skipping Subclassing entirely</h3>
<p>We can skip the entire <code>extends Human</code> thing and create <code>Robot</code> as a new Class.</p>
<p>When we do this, we can become even more flexible. For example, let‚Äôs say our <code>Robot</code> only has a <code>firstName</code>. It doesn‚Äôt have <code>lastName</code>.</p>
<pre><code class="language-js">class Robot {
  constructor (firstName) {
    this.firstName = firstName
  }
}

Object.assign(Robot.prototype, canCode, canDesign)
</code></pre>
<p>A <code>Robot</code> instance can still <code>code</code> and <code>design</code>. And it still doesn‚Äôt know how to <code>sayName</code>.</p>
<pre><code class="language-js">const KD82 = new Robot('KD82')
KD82.sayName() // Error
KD82.code('website') // KD82 coded website
KD82.design('website') // KD82 designed website
</code></pre>
<h2 id="composition-via-oloo">Composition via OLOO</h2>
<p>You can compose mixins into OLOO with <code>Object.assign</code> as well.</p>
<pre><code class="language-js">const Human = {
  init (firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
    return this
  }
}

const Developer = Object.create(Human)
Object.assign(Developer, canCode, canSayName)
</code></pre>
<p>Developer instances will now be able to code and say their name. But they won‚Äôt be able to design.</p>
<pre><code class="language-js">const zell = Object.create(Developer).init('Zell', 'Liew')

zell.sayName() // Zell Liew
zell.code('website') // Zell coded website
zell.design('website') // Error
</code></pre>
<figure role="figure">
  <img src="../../images/oop/composition-vs-inheritance/developer.png" alt="Developer instance.">
</figure>
<h2 id="composition-via-factory-functions">Composition via Factory Functions</h2>
<p>You can also use <code>Object.assign</code> to compose mixins into Factory Functions.</p>
<pre><code class="language-js">function Human (firstName, lastName) {
  return {
    firstName,
    lastName
  }
}

function Developer (firstName, lastName) {
  const developer = Human(firstName, lastName)
  return Object.assign(developer, canCode, canSayName)
}
</code></pre>
<p>Developer instances will now be able to code and say their name. But they won‚Äôt be able to design.</p>
<pre><code class="language-js">const zell = Developer('Zell', 'Liew')

zell.sayName() // Zell Liew
zell.code('website') // Zell coded website
zell.design('website') // Error
</code></pre>
<figure role="figure">
  <img src="../../images/oop/composition-vs-inheritance/developer.png" alt="Developer instance.">
</figure>
<h2 id="is-subclassing-and-prototypal-delegation-useless-then%3F">Is Subclassing and Prototypal Delegation useless then?</h2>
<p>Nope! Prototypal Delegation is a design pattern. It‚Äôs up to you whether you want to use Composition (and hence use Copy-paste) or use Prototypal Delegation.</p>
<h3 id="when-to-favour-inheritance-over-composition">When to favour Inheritance over Composition</h3>
<p>You want to favour Inheritance over Composition when you know the derivative object completely inherits all properties of the parent object.</p>
<p>There are lots of great examples of this in the wild.</p>
<p>For example, <code>Array</code> derives from <code>Object</code>. If you look at an Object‚Äôs prototype, you see methods like <code>hasOwnProperty</code>, <code>isPrototypeOf</code>, <code>toString</code>, <code>valueOf</code>, and others.</p>
<figure role="figure">
  <img src="../../images/oop/composition-vs-inheritance/object-prototype.png" alt="Object Prototype">
</figure>
<p>If you open up an Array‚Äôs prototype, you‚Äôll see methods you‚Äôre familiar with, like <code>find</code> and <code>slice</code>.</p>
<figure role="figure">
  <img src="../../images/oop/composition-vs-inheritance/array-prototype.png" alt="Array prototype">
</figure>
<p>If you open an Array prototype‚Äôs prototype, you‚Äôll see the same properties Object‚Äôs prototype.</p>
<figure role="figure">
  <img src="../../images/oop/composition-vs-inheritance/array-prototype-2.png" alt="Second level into Array.prototype">
</figure>
<p>This is why we say Array is an Object. (In fact, everything are objects in JavaScript, including primitives like strings. Try writing <code>new String</code> and explore!).</p>
<p>Another example: <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement">Go look up <code>HTMLElement</code> on MDN</a>. You‚Äôll see this flowchart.</p>
<figure role="figure">
  <img src="../../images/oop/composition-vs-inheritance/html-element.png" alt="HTMLElement on MDN.">
</figure>
<p>What this says is:</p>
<ol>
<li><code>HTMLElement</code> inherits from <code>Element</code></li>
<li><code>Element</code> inherits from <code>Node</code></li>
<li><code>Node</code> inherits from <code>EventTarget</code></li>
</ol>
<p>This means:</p>
<ol>
<li><code>Node</code>s will have properties available to <code>EventTarget</code>s</li>
<li><code>Element</code> will have properties available to <code>EventTarget</code> and <code>Node</code></li>
<li><code>HTMLElement</code> will have properties available to  <code>EventTarget</code> and <code>Node</code> and <code>Element</code>.</li>
</ol>
<p>And if you dig further, you‚Äôll notice <code>EventTarget</code> contains three methods:</p>
<ol>
<li><code>EventTarget.addEventListener()</code></li>
<li><code>EventTarget.removeEventListener()</code></li>
<li><code>EventTarget.dispatchEvent()</code></li>
</ol>
<p>Now you understand why HTML Elements have <code>addEventListener</code> and <code>removeEventListener</code>? üòÑ</p>
</article>
  </div>



  <div class="longform">
    <nav class="lesson-nav">

          <a href="../creating-derivative-objects/index.html" data-link-to="previous-lesson">
              <svg height="1em" viewbox="0 0 22 38">
                <path
          fill="currentColor"
          d="M18.9 38l3.1-3.1L6.1 19 22 3.1 18.9 0 0 19z"
        ></path>
              </svg>
              <span>Creating Derivative Objects</span>
            </a>
          <a href="../polymorphism/index.html" data-link-to="next-lesson">
              <span>Polymorphism</span>
              <svg height="1em" viewbox="0 0 22 38">
                <path
          fill="currentColor"
          d="M3.1 0L0 3.1 15.9 19 0 34.9 3.1 38 22 19z"
        ></path>
              </svg>
            </a>
          </nav>
  </div>
</div>
    </main>



      <script module src="../../js/main-b9439821d7.mjs"></script>
      <script nomodule src="../../js/main-legacy-8c54230a8f.js"></script>
  </body>

<!-- /composition-vs-inheritance/  Mon, 24 Jan 2022 10:07:11 GMT -->
</html>
